main(packageName, name, entry, fromCase, toCase) ::= <<
// This file is auto-generated from the $name$ class hierarchy

package $packageName$

import org.sireum.util._
import org.sireum.util.Json._
import upickle.Js

object Rewriter {
  import org.sireum.util.Rewriter._

  val constructorMap : ConstructorMap = Map(
    $entry; separator=",\n"$
  )

  def build[T](mode: TraversalMode.Type = TraversalMode.TOP_DOWN)(
    f: RewriteFunction) =
    org.sireum.util.Rewriter.build[T](constructorMap)(mode, f)

  def buildEnd[T](mode: TraversalMode.Type = TraversalMode.TOP_DOWN)(
      f: RewriteFunction, g: RewriteFunction) =
    org.sireum.util.Rewriter.buildEnd[T](constructorMap)(mode, f, g)
}

object Pickling {
  def pickle(node: Node): String =
    upickle.json.write(Json.from(node))

  def unpickle[T <: Node](s: String): T =
    Json.to[T](upickle.json.read(s))
}

object Json {
  def from(o: $name$): Js.Obj =
    o match {
      $fromCase; separator="\n"$
    }

  def to[T <: $name$](v: Js.Value): T =
    (v: @unchecked) match {
      case o: Js.Obj =>
        (o.value.head._2.asInstanceOf[Js.Str].value match {
           $toCase; separator="\n"$
         }).asInstanceOf[T]
    }
}
>>

constructorEntry(name, et, ec) ::= <<
"$name$" -> { es =>
  val Seq($et; separator=", "$) = es
  $name$($ec; separator=", "$)
}
>>

caseFrom(name, arg) ::= <<
case o: $name$ =>
  Js.Obj(
    (".class", Js.Str("$name$")),
    $arg; separator=",\n"$
  )
>>

caseFromArg(name, type, arg) ::= <<
("$name$", $type$(o.$name$$if(arg)$, $arg; separator=", "$$endif$))
>>

caseTo(name, arg) ::= <<
case "$name$" =>
  $name$($arg; separator=", "$)
>>

caseToArg(type, i, arg) ::= <<
$type$(o.value($i$)._2$if(arg)$, $arg; separator=", "$$endif$)
>>