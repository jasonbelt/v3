mainRewriter(license, packageName, name, rootClass, entry) ::= <<
%if(license)%
/*
%license%
*/

%endif%
// This file was auto-generated from %rootClass%

%if(packageName)%
package %packageName%

%endif%
import org.sireum.util._

object %name% {
  import org.sireum.util.Rewriter._

  val constructorMap : ConstructorMap = Map(
    %entry; separator=",\n"%
  )

  def build[T](mode: TraversalMode.Type = TraversalMode.TOP_DOWN)(
    f: RewriteFunction) =
    org.sireum.util.Rewriter.build[T](constructorMap)(mode, f)

  def buildEnd[T](mode: TraversalMode.Type = TraversalMode.TOP_DOWN)(
      f: RewriteFunction, g: RewriteFunction) =
    org.sireum.util.Rewriter.buildEnd[T](constructorMap)(mode, f, g)
}
>>

mainJson(license, packageName, name, rootClass, fromCase, toCase) ::= <<
%if(license)%
/*
%license%
*/

%endif%
// This file was auto-generated from %rootClass%

%if(packageName)%
package %packageName%

%endif%
import upickle.Js
import org.sireum.util.Json._

object %name% {
  import scala.language.implicitConversions

  implicit def from(o: %rootClass%): Js.Obj =
    o match {
      %fromCase; separator="\n"%
    }

  implicit def to[T <: %rootClass%](v: Js.Value): T =
    (v: @unchecked) match {
      case o: Js.Obj =>
        (o.value.head._2.asInstanceOf[Js.Str].value match {
           %toCase; separator="\n"%
         }).asInstanceOf[T]
    }
}
>>

constructorEntry(name, et, ec) ::= <<
("%name%", { es =>
  val Seq(%et; separator=", "%) = es
  %name%(%ec; separator=", "%)
})
>>

caseFrom(name, arg) ::= <<
case o: %name% =>
  Js.Obj(
    (".class", Js.Str("%name%")),
    %arg; separator=",\n"%
  )
>>

caseFromArg(name, type, arg) ::= <<
("%name%", %type%(o.%name%)%if(arg)%(%arg; separator=", "%)%endif%)
>>

caseTo(name, arg) ::= <<
case "%name%" =>
  %name%(%arg; separator=", "%)
>>

caseToArg(type, i, arg) ::= <<
%type%(o.value(%i%)._2)%if(arg)%(%arg; separator=", "%)%endif%
>>